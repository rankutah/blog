{{- /* Section with optional hero & overlay + site defaults + spacer control.
     Adds render mode:
       render="md|raw|auto" (default "md")
       - md   → render Markdown via Page.RenderString
       - raw  → output inner as-is (safeHTML), for nested shortcodes/components
       - auto → detect {{< or {{% → raw, else md
*/ -}}

{{- $page   := .Page -}}
{{- $Inner  := .Inner -}}

{{/* ---------- Read site defaults ---------- */}}
{{- $defs := $page.Site.Params.section.defaults | default (dict) -}}
{{- $defMax   := (index $defs "max")   | default "xl" -}}
{{- $defPad   := (index $defs "pad")   | default "lg" -}}
{{- $defY     := (index $defs "y")     | default "md" -}}
{{- $defAlign := (index $defs "align") | default "start" -}}
{{- $defAlignY:= (index $defs "alignY")| default "" -}}
{{- $defMinh  := (index $defs "minh")  | default "" -}}

{{/* ---------- Shortcode params ---------- */}}
{{- $pageOverride := .Get "classes" | default "" -}}
{{- $siteOverride := $page.Site.Params.section.classes | default "" -}}

{{- $max     := .Get "max"     | default $defMax -}}
{{- $pad     := .Get "pad"     | default $defPad -}}
{{- $y       := .Get "y"       | default $defY -}}
{{- $yBottom := .Get "yBottom" | default "" -}}
{{- $align   := .Get "align"   | default $defAlign -}}
{{- $alignY  := .Get "alignY"  | default $defAlignY -}}
{{- $minh    := .Get "minh"    | default $defMinh -}}

{{- $render  := lower (.Get "render" | default "md") -}} {{/* md | raw | auto */}}

{{/* ---------- First section detection (to allow flush hero) ---------- */}}
{{- $seen := $page.Scratch.Get "first_section_seen" | default false -}}
{{- $isFirstSection := not $seen -}}
{{- if not $seen -}}{{- $page.Scratch.Set "first_section_seen" true -}}{{- end -}}

{{/* ---------- Maps ---------- */}}
{{- $maxMap := dict "sm" "max-w-screen-sm" "md" "max-w-3xl" "lg" "max-w-5xl" "xl" "max-w-7xl" "2xl" "max-w-screen-2xl" "full" "max-w-none" -}}
{{- $padMap := dict "none" "px-0" "sm" "px-4" "md" "px-6" "lg" "px-8" -}}
{{- $alMap  := dict "start" "text-left" "center" "text-center" -}}

{{- $ptMap := dict "none" "pt-0" "sm" "pt-6" "md" "pt-12" "lg" "pt-16" "xl" "pt-24" -}}
{{- $pbMap := dict "none" "pb-0" "sm" "pb-6" "md" "pb-12" "lg" "pb-16" "xl" "pb-24" -}}

{{- $minhMap   := dict "" "" "screen" "min-h-screen" "full" "min-h-full" -}}
{{- $alignYMap := dict "" "" "start" "justify-start" "center" "justify-center" "end" "justify-end" "between" "justify-between" -}}

{{/* ---------- Hero controls ---------- */}}
{{- $img        := .Get "img" | default "" -}}
{{- $alt        := .Get "alt" | default "" -}}
{{- $bleedStr   := .Get "bleed" | default "" -}}
{{- $bleed      := cond (ne $img "") (ne (lower $bleedStr) "false") false -}}
{{- $imgClasses := .Get "imgClasses" | default "block w-full h-64 md:h-80 lg:h-96 object-cover" -}}
{{- $imgStyle   := .Get "imgStyle"   | default "" -}}
{{- $vhMode     := lower (.Get "vh" | default "") -}} {{/* "vh" | "svh" | "dvh" or empty */}}
{{- /* If author provided a vh-based inline height, append an svh duplicate so it wins on mobile. */ -}}
{{- $hasVhInStyle := and (ne $imgStyle "") (gt (len (findRE `\b[0-9.]+vh\b` $imgStyle)) 0) -}}
{{- if and (ne $img "") $hasVhInStyle -}}
  {{- /* Convert 50vh -> 50svh, 100vh -> 100svh, etc., and append so it overrides. */ -}}
  {{- $svhStyle := replaceRE `([0-9.]+)vh` `${1}svh` $imgStyle -}}
  {{- $imgStyle = printf "%s; %s" $imgStyle $svhStyle -}}
{{- end -}}
{{- /* If no explicit vh in style and no param, default to svh on the first hero. */ -}}
{{- if and (eq $vhMode "") (ne $img "") $isFirstSection (not $hasVhInStyle) -}}
  {{- $vhMode = "svh" -}}
{{- end -}}
{{- if and (ne $vhMode "") (ne $img "") -}}
  {{- /* Allow users to request viewport units without JS: we’ll prefer 100svh with 100vh fallback. */ -}}
  {{- if eq $vhMode "svh" -}}
    {{- $imgStyle = printf "height: 100vh; height: 100svh;%s" (cond (ne $imgStyle "") (printf " %s" $imgStyle) "") -}}
  {{- else if eq $vhMode "dvh" -}}
    {{- $imgStyle = printf "height: 100vh; height: 100dvh;%s" (cond (ne $imgStyle "") (printf " %s" $imgStyle) "") -}}
  {{- else if eq $vhMode "vh" -}}
    {{- $imgStyle = printf "height: 100vh;%s" (cond (ne $imgStyle "") (printf " %s" $imgStyle) "") -}}
  {{- end -}}
{{- end -}}

{{- $overlay      := eq (lower (.Get "overlay" | default "false")) "true" -}}
{{- $overlayShade := .Get "overlayShade" | default "" -}}
{{- $overlayWrap  := .Get "overlayClasses" | default "absolute inset-0 flex items-center" -}}
{{- $overlayProse := "prose prose-zinc max-w-none dark:prose-invert" -}}
{{- $overlayAlign := (index $alMap $align | default "text-left") -}}

{{/* Convenience: brighten flag -> apply a subtle white overlay unless overlayShade explicitly provided.
    Usage: brighten="sm|md|lg|true" → sm=10%, md=20% (default), lg=30% */}}
{{- $brightenParam := lower (.Get "brighten" | default "") -}}
{{- if and (ne $brightenParam "") (eq $overlayShade "") -}}
  {{- $overlay = true -}}
  {{- $level := cond (or (eq $brightenParam "true") (eq $brightenParam "md")) "20" (cond (eq $brightenParam "sm") "10" (cond (eq $brightenParam "lg") "30" "")) -}}
  {{- if ne $level "" -}}
    {{- $overlayShade = printf "bg-white/%s" $level -}}
  {{- else -}}
    {{- $overlayShade = "bg-white/20" -}}
  {{- end -}}
{{- end -}}

{{/* Spacer control (only relevant for bleed+overlay) */}}
{{- $spacerParam := lower (.Get "spacer" | default "true") -}}

{{/* ---------- Compute paddings ---------- */}}
{{- /* If this is the first section and it's a hero (has img), remove top padding to sit flush under the nav. */ -}}
{{- $pt := cond (or $bleed (and $isFirstSection (ne $img ""))) "pt-0" (index $ptMap $y | default "pt-12") -}}
{{- $pb := index $pbMap $y | default "pb-12" -}}
{{- if $yBottom }}{{- $pb = index $pbMap $yBottom | default $pb -}}{{- end -}}

{{/* ---------- Container class ---------- */}}
{{- $container := printf "%s mx-auto %s %s %s"
    (index $maxMap $max   | default "max-w-7xl")
    (index $padMap $pad   | default "px-8")
    $pt
    (index $alMap  $align | default "text-left")
-}}

{{/* Optional vertical centering wrapper */}}
{{- $vWrap := "" -}}
{{- if or (ne $alignY "") (ne $minh "") -}}
  {{- $vWrap = printf "flex flex-col w-full %s %s"
        (index $minhMap $minh | default "")
        (index $alignYMap $alignY | default "")
  -}}
{{- end -}}

{{- $base := printf "%s %s" $container $pb -}}
{{- $classes := cond (ne $pageOverride "") $pageOverride (cond (ne $siteOverride "") $siteOverride $base) -}}

{{/* ---------- Smart renderer (with shortcode support) ---------- */}}
{{- $innerRaw := $Inner -}}
{{- $hasShortcode := gt (len (findRE `{{[%<]` $innerRaw)) 0 -}}
{{- $opts := dict "markup" "goldmark" "renderShortcodes" true -}}
{{- if eq $render "auto" -}}
  {{- /* In auto mode, always render Markdown and allow shortcodes. */ -}}
  {{- $render = "md" -}}
{{- end -}}
{{- $innerOut := "" -}}
{{- if eq $render "raw" -}}
  {{- /* Raw preserves the inner HTML exactly (no shortcode rendering). */ -}}
  {{- $innerOut = $innerRaw | safeHTML -}}
{{- else -}}
  {{- /* md → RenderString with shortcode expansion enabled. */ -}}
  {{- $innerOut = $page.RenderString $opts $innerRaw -}}
{{- end -}}

{{- $isHero := and (ne $img "") $bleed -}}
{{- $secClass := slice -}}
{{- $secClass = $secClass | append "section" -}}
{{- if $isHero }}{{ $secClass = $secClass | append "hero" }}{{ end -}}
{{- if $bleed }}{{ $secClass = $secClass | append "bleed" }}{{ end -}}
{{- /* If this page declares hero (img present) but not bleed, still mark section as hero-nonbleed for top-pad removal on landing pages */ -}}
{{- if and (ne $img "") (not $bleed) -}}
  {{- $secClass = $secClass | append "hero-nonbleed" -}}
{{- end -}}
<section class="{{ delimit $secClass " " }}"{{ if and $isFirstSection (or $isHero (and (ne $img "") (not $bleed))) }} style="margin-top:0;padding-top:0"{{ end }}>
  {{- if and $img $bleed -}}
    <!-- Full-bleed hero -->
    <div class="relative left-1/2 right-1/2 ml-[-50vw] mr-[-50vw] w-screen">
  {{- $imgStr := $img | safeURL -}}
  {{- $srcset := slice -}}
  {{- $srcsetAvif := slice -}}
  {{- /* WebP disabled: keep outputs to AVIF + JPEG */ -}}
  {{- $srcsetWebp := slice -}}
  {{- $fallbackSrc := $imgStr -}}
  {{- $isRaster := gt (len (findRE `\.(jpg|jpeg|png|webp|avif)$` (lower $imgStr))) 0 -}}
  {{- $isMedia := or (hasPrefix $imgStr "/media/") (hasPrefix $imgStr "media/") (hasPrefix $imgStr "./media/") (hasPrefix $imgStr "../media/") -}}
  {{- if and $isRaster $isMedia -}}
    {{- $noLead := replaceRE "^(/|\\./|\\.\\./)" "" $imgStr -}}
    {{- $asset := resources.Get $noLead -}}
    {{- $last := "" -}}
    {{- if and $asset (eq ($asset.MediaType.MainType | default "") "image") -}}
      {{- $sub := lower ($asset.MediaType.SubType | default "") -}}
      {{- $processable := in (slice "jpeg" "jpg" "png") $sub -}}
      {{- if $processable -}}
        {{- /* Avoid reading intrinsic width; just generate common widths */ -}}
        {{- $widths := slice 720 1080 1440 1920 -}}
        {{- $last = "" -}}
        {{- range $w := $widths -}}
          {{- /* Always generate variants; Hugo avoids enlarging when not needed */ -}}
            {{- $r := $asset.Resize (printf "%dx" $w) -}}
            {{- $srcset = $srcset | append (printf "%s %dw" $r.RelPermalink $w) -}}
            {{- $last = $r.RelPermalink -}}
            {{- $ravif := $asset.Resize (printf "%dx avif" $w) -}}
            {{- /* Only include AVIF candidate if the output truly is .avif */ -}}
            {{- if (hasSuffix (lower $ravif.RelPermalink) ".avif") -}}
              {{- $srcsetAvif = $srcsetAvif | append (printf "%s %dw" $ravif.RelPermalink $w) -}}
            {{- end -}}
            {{- /* No WebP variant generation */ -}}
        {{- end -}}
        {{- if ne $last "" }}{{ $fallbackSrc = $last }}{{ end -}}
      {{- else -}}
        {{- /* Unprocessable by Hugo pipeline (e.g., AVIF/WEBP as source). Use original as fallback and provide type-specific source. */ -}}
        {{- $fallbackSrc = $asset.RelPermalink -}}
        {{- if eq $sub "avif" -}}
          {{- $srcsetAvif = (slice $asset.RelPermalink) -}}
        {{- else if eq $sub "webp" -}}
          {{- /* Ignore WebP source; allow JPEG fallback below */ -}}
        {{- end -}}
      {{- end -}}
    {{- end -}}
    {{- /* Skip width/height hints to avoid calling methods unsupported on some formats (e.g., AVIF) */ -}}
  {{- else -}}
    {{- /* Fallback: try a static AVIF sibling if present */ -}}
    {{- if or (hasPrefix $imgStr "/media/") (hasPrefix $imgStr "media/") -}}
      {{- $noLead := replaceRE "^/" "" $imgStr -}}
      {{- $avifRel := replaceRE `\.(jpg|jpeg|png|webp)$` ".avif" $noLead -}}
      {{- $staticPath := printf "static/%s" $avifRel -}}
      {{- if fileExists $staticPath -}}
        {{- $srcsetAvif = (slice (printf "/%s 1920w" $avifRel)) -}}
      {{- end -}}
      {{- $fallbackSrc = printf "/%s" $noLead -}}
    {{- end -}}
  {{- end -}}
  <picture>
    {{- if gt (len $srcsetAvif) 0 -}}<source type="image/avif" srcset="{{ delimit $srcsetAvif ", " }}" sizes="100vw">{{- end -}}
  {{- /* No WebP <source> */ -}}
  <img src="{{ $fallbackSrc }}"{{ if gt (len $srcset) 0 }} srcset="{{ delimit $srcset ", " }}" sizes="100vw"{{ end }} alt="{{ $alt }}" class="not-prose {{ $imgClasses }}"{{ if $imgStyle }} style="{{ $imgStyle | safeCSS }}"{{ end }} loading="eager" fetchpriority="high" decoding="async">
  </picture>
      {{- if $overlay -}}
        <div class="{{ $overlayWrap }}">
          {{- if $overlayShade }}<div class="absolute inset-0 {{ $overlayShade }}"></div>{{- end }}
          <div class="relative z-10 w-full {{ $container }}">
            <div class="{{ $vWrap }}">
              <div class="{{ $overlayProse }} {{ $overlayAlign }}">
                {{- $innerOut -}}
              </div>
            </div>
          </div>
        </div>
      {{- end }}
    </div>

    {{- /* Spacer only if bottom padding is non-zero AND not explicitly disabled */ -}}
    {{- $addSpacer := and (ne $pb "pb-0") (ne $spacerParam "false") -}}
    {{- if $addSpacer -}}
      <div class="{{ (printf "%s mx-auto %s" (index $maxMap $max | default "max-w-7xl") (index $padMap $pad | default "px-8")) }} {{ $pb }}"></div>
    {{- end }}

  {{- else if $img -}}
    <!-- In-container hero -->
    <div class="{{ $classes }}">
      <div class="relative">
  {{- $imgStr := $img | safeURL -}}
  {{- $srcset := slice -}}
  {{- $srcsetAvif := slice -}}
  {{- /* WebP disabled: keep outputs to AVIF + JPEG */ -}}
  {{- $srcsetWebp := slice -}}
  {{- $fallbackSrc := $imgStr -}}
  {{- $isRaster := gt (len (findRE `\.(jpg|jpeg|png|webp|avif)$` (lower $imgStr))) 0 -}}
  {{- $isMedia := or (hasPrefix $imgStr "/media/") (hasPrefix $imgStr "media/") (hasPrefix $imgStr "./media/") (hasPrefix $imgStr "../media/") -}}
  {{- if and $isRaster $isMedia -}}
    {{- $noLead := replaceRE "^(/|\\./|\\.\\./)" "" $imgStr -}}
    {{- $asset := resources.Get $noLead -}}
    {{- $last := "" -}}
    {{- if and $asset (eq ($asset.MediaType.MainType | default "") "image") -}}
      {{- $sub := lower ($asset.MediaType.SubType | default "") -}}
      {{- $processable := in (slice "jpeg" "jpg" "png") $sub -}}
      {{- if $processable -}}
        {{- $widths := slice 720 1080 1440 1920 -}}
        {{- $last = "" -}}
        {{- range $w := $widths -}}
          {{- /* Always generate variants; Hugo avoids enlarging when not needed */ -}}
            {{- $r := $asset.Resize (printf "%dx" $w) -}}
            {{- $srcset = $srcset | append (printf "%s %dw" $r.RelPermalink $w) -}}
            {{- $last = $r.RelPermalink -}}
            {{- $ravif := $asset.Resize (printf "%dx avif" $w) -}}
            {{- if (hasSuffix (lower $ravif.RelPermalink) ".avif") -}}
              {{- $srcsetAvif = $srcsetAvif | append (printf "%s %dw" $ravif.RelPermalink $w) -}}
            {{- end -}}
            {{- /* No WebP variant generation */ -}}
        {{- end -}}
        {{- if ne $last "" }}{{ $fallbackSrc = $last }}{{ end -}}
      {{- else -}}
        {{- $fallbackSrc = $asset.RelPermalink -}}
        {{- if eq $sub "avif" -}}
          {{- $srcsetAvif = (slice $asset.RelPermalink) -}}
        {{- else if eq $sub "webp" -}}
          {{- /* Ignore WebP source; allow JPEG fallback below */ -}}
        {{- end -}}
      {{- end -}}
    {{- end -}}
  {{- /* Skip width/height hints for same reason as above */ -}}
    {{- if or (hasPrefix $imgStr "/media/") (hasPrefix $imgStr "media/") -}}
      {{- $noLead := replaceRE "^/" "" $imgStr -}}
      {{- $avifRel := replaceRE `\.(jpg|jpeg|png|webp)$` ".avif" $noLead -}}
      {{- $staticPath := printf "static/%s" $avifRel -}}
      {{- if fileExists $staticPath -}}
        {{- $srcsetAvif = (slice (printf "/%s 1920w" $avifRel)) -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  <picture>
    {{- if gt (len $srcsetAvif) 0 -}}<source type="image/avif" srcset="{{ delimit $srcsetAvif ", " }}" sizes="100vw">{{- end -}}
  {{- /* No WebP <source> */ -}}
  <img src="{{ $fallbackSrc }}"{{ if gt (len $srcset) 0 }} srcset="{{ delimit $srcset ", " }}" sizes="100vw"{{ end }} alt="{{ $alt }}" class="not-prose block w-full {{ $imgClasses }}"{{ if $imgStyle }} style="{{ $imgStyle | safeCSS }}"{{ end }} loading="eager" fetchpriority="high" decoding="async">
  </picture>
        {{- if $overlay -}}
          <div class="{{ $overlayWrap }}">
            {{- if $overlayShade }}<div class="absolute inset-0 {{ $overlayShade }}"></div>{{- end }}
            <div class="relative z-10 w-full">
              <div class="{{ $vWrap }}">
                <div class="{{ $overlayProse }} {{ $overlayAlign }}">
                  {{ $innerOut }}
                </div>
              </div>
            </div>
          </div>
        {{- else -}}
          <div class="{{ $overlayProse }} {{ $overlayAlign }} mt-6">
            {{ $innerOut }}
          </div>
        {{- end }}
      </div>
    </div>

  {{- else -}}
    <!-- Regular section -->
    <div class="{{ $classes }}">
      {{- if $vWrap }}<div class="{{ $vWrap }}">{{ end -}}
        {{ $innerOut }}
      {{- if $vWrap }}</div>{{ end -}}
    </div>
  {{- end }}
</section>

{{- if hugo.IsServer -}}
<!-- debug: render={{$render}} hasShortcode={{$hasShortcode}} -->
{{- end -}}
