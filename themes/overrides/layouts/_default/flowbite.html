{{/* themes/overrides/layouts/_default/flowbite.html */}}
<!DOCTYPE html>
<html class="{{ .Site.Params.primaryColor | default "rose" }}" lang="{{ .Site.Language.Lang }}" dir="{{ .Site.Language.LanguageDirection | default "auto" }}">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ .Title }} | {{ .Site.Title }}</title>

  {{ partial "seo-meta.html" . }}

  <!-- Dark-mode bootstrap: ensure html.dark matches forced attr, saved pref, or OS on first paint -->
  <script>
    (function(){
      var html = document.documentElement;
      function getStored(){ try { return localStorage.getItem('pref-theme'); } catch(e){ return null; } }
      function prefersDark(){ try { return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(e){ return false; } }
      function wantDark(){
        var forced = html.getAttribute('data-force-theme');
        if (forced === 'dark') return true;
        if (forced === 'light') return false;
        var stored = getStored();
        if (stored === 'dark') return true;
        if (stored === 'light') return false;
        return prefersDark();
      }
      function apply(){ var d = wantDark(); if (d) html.classList.add('dark'); else html.classList.remove('dark'); }
      // Initial apply before CSS to avoid FOUC
      apply();
      // React to changes of data-force-theme
      try {
        new MutationObserver(function(muts){ for (var i=0;i<muts.length;i++){ if (muts[i].attributeName === 'data-force-theme'){ apply(); break; } } })
          .observe(html, { attributes:true });
      } catch(e){}
      // React to OS changes
      try {
        var mql = window.matchMedia('(prefers-color-scheme: dark)');
        if (mql && mql.addEventListener) mql.addEventListener('change', apply);
        else if (mql && mql.addListener) mql.addListener(apply);
      } catch(e){}
      // React to localStorage changes (other tabs)
      try { window.addEventListener('storage', function(e){ if (e && e.key === 'pref-theme') apply(); }); } catch(e){}
    })();
  </script>

  <!-- Brand/Theme recolor on first paint -->
  <script>
    (function(){
      const html = document.documentElement;
      const BRAND_HEX = {
        gray:{light:"#4b5563",dark:"#6b7280"}, neutral:{light:"#525252",dark:"#737373"},
        red:{light:"#dc2626",dark:"#ef4444"}, orange:{light:"#ea580c",dark:"#f97316"},
        amber:{light:"#d97706",dark:"#f59e0b"}, yellow:{light:"#ca8a04",dark:"#eab308"},
        lime:{light:"#65a30d",dark:"#84cc16"}, green:{light:"#16a34a",dark:"#22c55e"},
        emerald:{light:"#059669",dark:"#10b981"}, teal:{light:"#0d9488",dark:"#14b8a6"},
        cyan:{light:"#0891b2",dark:"#06b6d4"}, sky:{light:"#0284c7",dark:"#0ea5e9"},
        blue:{light:"#2563eb",dark:"#3b82f6"}, indigo:{light:"#4f46e5",dark:"#6366f1"},
        violet:{light:"#7c3aed",dark:"#8b5cf6"}, purple:{light:"#9333ea",dark:"#a855f7"},
        fuchsia:{light:"#c026d3",dark:"#d946ef"}, pink:{light:"#db2777",dark:"#ec4899"},
        rose:{light:"#e11d48",dark:"#f43f5e"}
      };
      const SITE_BRAND = (html.getAttribute('data-brand') || (html.className || 'blue').split(' ')[0] || 'blue');
      function currentBrand(){ return (html.getAttribute('data-brand') || SITE_BRAND || 'blue').trim(); }
      function recolorNavbar(){
        const isDark = html.classList.contains('dark');
        const pal = BRAND_HEX[currentBrand()] || BRAND_HEX.blue;
        const fg  = isDark ? pal.dark : pal.light;
        document.querySelectorAll('nav .nav-brand, [data-brand-nav="fg"]').forEach(el=>el&&(el.style.color=fg));
        document.querySelectorAll('nav .nav-brand-bg, [data-brand-nav="bg"]').forEach(el=>el&&(el.style.backgroundColor=fg));
        document.querySelectorAll('nav .nav-brand-border, [data-brand-nav="border"]').forEach(el=>el&&(el.style.borderColor=fg));
      }
      function recolorAll(){ recolorNavbar(); }
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', recolorAll, { once:true }); else recolorAll();
      new MutationObserver(m=>{ for(const x of m) if(x.attributeName==='class'){recolorAll();break;} }).observe(html,{attributes:true});
      window.addEventListener('cp:brandchange', function(e){ if(e&&e.detail) html.setAttribute('data-brand', e.detail); recolorAll(); });
    })();
  </script>

  <!-- Load Flowbite JS only when explicitly requested at page or site level -->
  {{- $useFlowbite := or (eq .Params.useFlowbiteJS true) (eq site.Params.useFlowbiteJS true) -}}
  {{- if $useFlowbite -}}
    <script src='{{ "js/flowbite.min.js" | relURL }}' defer onload="try{window.initCarousels&&window.initCarousels()}catch(e){}"></script>
  {{- end -}}

  {{- /* Tailwind + Flowbite CSS via Hugo Pipes + minify + fingerprint (blocking to prevent FOUC) */ -}}
  {{- $css := resources.Get "css/main.css" | postCSS | minify | fingerprint "sha384" }}
  <!-- Ensure preload and stylesheet use identical URL and integrity to avoid SRI mismatch warnings -->
  <link rel="preload" as="style" href="{{ $css.RelPermalink }}" {{ if $css.Data.Integrity }}integrity="{{ $css.Data.Integrity }}"{{ end }} crossorigin="anonymous">
  <link rel="stylesheet"
    href="{{ $css.RelPermalink }}"
    {{ if $css.Data.Integrity }}integrity="{{ $css.Data.Integrity }}"{{ end }}
    crossorigin="anonymous">

  <!-- Carousel v2 scoped polish (fallbacks for visibility/positioning) -->
  <style>
    /* Ensure viewport is positioning context */
    [data-carousel-ver="2"] [data-carousel-viewport] { position: relative; }
    /* Dots visible by default; brighter when active via aria-current */
    [data-carousel-ver="2"] [data-carousel-slide-to] {
      width: 0.75rem; height: 0.75rem; border-radius: 9999px;
      background-color: rgba(255, 255, 255, 0.35);
    }
    [data-carousel-ver="2"] [data-carousel-slide-to][aria-current="true"] {
      background-color: rgba(255, 255, 255, 0.9);
    }
    /* Vertical centering fallback for nav arrows */
    [data-carousel-ver="2"] [data-carousel-prev],
    [data-carousel-ver="2"] [data-carousel-next] {
      position: absolute; top: 50%; transform: translateY(-50%);
    }

    /* Lite carousel (custom) styles */
    /* Lite carousel base positioning */
    [data-lite-carousel] [data-carousel-viewport] { position: relative; }
  /* Initial offscreen positioning so only the first slide is in view before JS runs */
  [data-lite-carousel] .lite-slide { transform: translateX(100%); }
  [data-lite-carousel] .lite-slide[data-index="0"] { transform: translateX(0); }
    /* Uniform heights via CSS variables (set on the carousel root) */
    /* Slightly lower default on mobile to keep controls within frame */
    [data-lite-carousel] [data-carousel-viewport] { height: var(--lc-h-mobile, 520px); }
    @media (min-width: 768px) {
      [data-lite-carousel] [data-carousel-viewport] { height: var(--lc-h-md, var(--lc-h-mobile, 520px)); }
    }
    [data-lite-carousel] .lite-dots {
      position: absolute; left: 0; right: 0;
      display: flex; gap: 0.75rem; justify-content: center; align-items: center;
      bottom: clamp(0.5rem, 2.5vh, 1.25rem);
    }
    /* Dots: match arrow colors; unselected = dark pill, selected = solid white */
    [data-lite-carousel] .lite-dot {
      width: 0.8rem; height: 0.8rem; border-radius: 9999px;
      background-color: rgba(0,0,0,0.45); /* same as .lite-nav-bg base */
      border: 1px solid rgba(255,255,255,0.75); /* subtle white border for visibility */
      box-shadow: none; /* solid circle, no extra ring */
    }
    [data-lite-carousel] .lite-dot[aria-current="true"] {
      background-color: rgba(255,255,255,0.98); /* bright white like arrow icon */
    }
    [data-lite-carousel] .lite-dot:focus-visible { outline: 2px solid rgba(255,255,255,0.9); outline-offset: 2px; }

  /* Controls overlay (ensures all controls anchor to viewport bounds) */
  [data-lite-carousel] .lite-controls { position: absolute; inset: 0; z-index: 30; pointer-events: none; display:grid; grid-template-rows: 1fr auto; grid-template-columns: 1fr; }
    [data-lite-carousel] .lite-controls .lite-prev,
    [data-lite-carousel] .lite-controls .lite-next,
    [data-lite-carousel] .lite-controls .lite-dots { pointer-events: auto; }

    /* Nav buttons: darker pill with subtle border and shadow for visibility */
    [data-lite-carousel] .lite-prev > .lite-nav-bg,
    [data-lite-carousel] .lite-next > .lite-nav-bg {
      background-color: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.6);
      box-shadow: 0 2px 6px rgba(0,0,0,0.45);
    }
    [data-lite-carousel] .lite-prev:hover > .lite-nav-bg,
    [data-lite-carousel] .lite-next:hover > .lite-nav-bg {
      background-color: rgba(0,0,0,0.6);
    }
    [data-lite-carousel] .lite-prev,
    [data-lite-carousel] .lite-next { position:absolute; top:50%; transform:translateY(-50%); }

    /* Reduce top gap before first grid heading on non-hero pages */
    .section:first-of-type .cols-auto .flex > h2:first-child { margin-top: 0.25rem; }
  </style>

  {{- /* Analytics (match PaperMod behavior: only in production) */ -}}
  {{- if or (hugo.IsProduction) (eq site.Params.env "production") -}}
    {{ partial "google_analytics.html" . }}
  {{- end -}}

  {{- /* Favicons */ -}}
  {{ partial "favicons.html" . }}

  {{- /* LCP preload */ -}}
  {{ partial "lcp-preload.html" . }}

  {{- /* JSON-LD schema (Event and per-page LocalBusiness) */ -}}
  {{ partial "schema.html" . }}
</head>

{{- /* Get shared palette once; use for body + navbar */ -}}
{{- $pal := partial "theme/palette.html" . -}}

<body id="top" class="flowbite-landing {{ $pal.bodyBg }} {{ $pal.bodyText }} transition-colors duration-200 twinkle-bg">
  {{ partial "navbar.html" . }}

  {{- /* If this is the homepage, or the page declares a hero, or uses a landing layout, remove the top pad */ -}}
  {{- $isHeroPage := or .IsHome .Params.hero (eq .Params.layout "landing") -}}
  <main id="content" class="min-h-screen{{ if $isHeroPage }} no-top-pad{{ end }}" data-bg-sync{{ if $isHeroPage }} style="padding-top:0;margin-top:0"{{ end }}>
    <article class="prose prose-zinc max-w-none dark:prose-invert"{{ if $isHeroPage }} style="margin-top:0"{{ end }}>
      {{ .Content }}
    </article>
  </main>

  <!-- Inline tiny UI for navbar collapse/dropdowns (removes JS request chain) -->
  <script type="module">
    function ready(fn){if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',fn,{once:true});}else{fn();}}
    function initCollapse(){
      // Basic collapses; skip if target is our drawer
      document.querySelectorAll('[data-collapse-toggle]').forEach(btn=>{
        const id=btn.getAttribute('data-collapse-toggle');
        const target=id&&document.getElementById(id);
        if(!target) return;
        if (target.hasAttribute('data-drawer')) return; // handled by drawer initializer
        btn.addEventListener('click',()=>{
          const isHidden=target.classList.toggle('hidden');
          btn.setAttribute('aria-expanded',String(!isHidden));
        });
      });
    }
    function initDropdowns(){const buttons=Array.from(document.querySelectorAll('[data-dropdown-toggle]'));if(!buttons.length)return;function closeAll(exceptId){buttons.forEach(b=>{const id=b.getAttribute('data-dropdown-toggle');const el=id&&document.getElementById(id);if(!el||id===exceptId)return;el.classList.add('hidden');b.setAttribute('aria-expanded','false');});}
      buttons.forEach(btn=>{const id=btn.getAttribute('data-dropdown-toggle');const menu=id&&document.getElementById(id);if(!menu)return;btn.addEventListener('click',(e)=>{e.stopPropagation();const nowHidden=menu.classList.toggle('hidden');btn.setAttribute('aria-expanded',String(!nowHidden));if(!nowHidden)closeAll(id);});});
      document.addEventListener('click',(e)=>{const inside=e.target.closest&&(e.target.closest('[data-dropdown-toggle]')||e.target.closest('[id^="menu-"]'));if(!inside)closeAll();});}
    // Apply responsive pixel heights to carousels based on data-* attributes
    function initCarouselHeights(){
      const mqlMd = window.matchMedia('(min-width: 768px)');
      const mqlLg = window.matchMedia('(min-width: 1024px)');
      const viewports = Array.from(document.querySelectorAll('[data-carousel-viewport]'));
      if(!viewports.length) return;

      function apply(){
        viewports.forEach(vp=>{
          const mob = vp.getAttribute('data-mobile-height');
          const md  = vp.getAttribute('data-md-height');
          const lg  = vp.getAttribute('data-lg-height');
          const fixed = vp.getAttribute('data-fixed-height');
          let h = '';
          if (lg && mqlLg.matches) h = lg;
          else if (md && mqlMd.matches) h = md;
          else if (mob) h = mob;
          else if (fixed) h = fixed;
          if (h) {
            const n = parseInt(h, 10);
            if (!isNaN(n)) vp.style.height = n + 'px';
          }
        });
      }
      apply();
      // Re-apply on breakpoint changes and resize
      let rafId = 0;
      function onResize(){
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(apply);
      }
      window.addEventListener('resize', onResize);
      if (mqlMd.addEventListener) {
        mqlMd.addEventListener('change', onResize);
        mqlLg.addEventListener('change', onResize);
      } else if (mqlMd.addListener) { // Safari <14 fallback
        mqlMd.addListener(onResize); mqlLg.addListener(onResize);
      }
    }
    // Auto-close legacy collapsible mobile menu when a menu link is clicked (no-op for drawer)
    function initAutoCloseMobileMenu(){
      const btn = document.querySelector('[data-collapse-toggle="navbar-sticky"]');
      const menu = document.getElementById('navbar-sticky');
      if(!btn||!menu) return;
      if (menu.hasAttribute('data-drawer')) return; // handled by drawer logic
      const isMobile = () => window.matchMedia('(max-width: 767.98px)').matches; // Tailwind md breakpoint
      menu.querySelectorAll('a[href]').forEach(a=>{
        a.addEventListener('click',()=>{
          if(!isMobile()) return;
          menu.classList.add('hidden');
          btn.setAttribute('aria-expanded','false');
          document.querySelectorAll('[id^="menu-"]').forEach(el=>el.classList.add('hidden'));
          document.querySelectorAll('[data-dropdown-toggle]').forEach(b=>b.setAttribute('aria-expanded','false'));
        }, { passive:true });
      });
    }
    // Mobile drawer for navbar (off-canvas)
    function initMobileDrawer(){
      const btn = document.querySelector('[data-collapse-toggle]');
      if(!btn) return;
      const targetId = btn.getAttribute('data-collapse-toggle');
      const drawer = targetId && document.getElementById(targetId);
      const overlay = document.getElementById('nav-drawer-overlay');
      if(!btn || !drawer || !overlay) return;
      if (!drawer.hasAttribute('data-drawer')) return; // only if configured as drawer
      const isMobile = () => window.matchMedia('(max-width: 767.98px)').matches; // Tailwind md breakpoint
      let lastFocus = null;
      const focusableSel = 'a[href], button:not([disabled]), [tabindex]:not([tabindex="-1"])';

      function open(){
        drawer.classList.remove('translate-x-full','pointer-events-none');
        overlay.classList.add('opacity-100','pointer-events-auto');
        drawer.setAttribute('aria-hidden','false');
        btn.setAttribute('aria-expanded','true');
        document.body.classList.add('overflow-hidden');
        lastFocus = document.activeElement;
        const first = drawer.querySelector(focusableSel);
        if (first) try{ first.focus(); }catch(e){}
        document.addEventListener('keydown', onKeydown);
      }
      function close(){
        drawer.classList.add('translate-x-full','pointer-events-none');
        overlay.classList.remove('opacity-100','pointer-events-auto');
        drawer.setAttribute('aria-hidden','true');
        btn.setAttribute('aria-expanded','false');
        document.body.classList.remove('overflow-hidden');
        document.removeEventListener('keydown', onKeydown);
        if (lastFocus && typeof lastFocus.focus === 'function') try{ lastFocus.focus(); }catch(e){}
      }
      function toggle(){ if(!isMobile()) return; const openState = drawer.getAttribute('aria-hidden') !== 'true'; openState ? close() : open(); }
      function onKeydown(e){
        if (e.key === 'Escape') { e.preventDefault(); close(); return; }
        if (e.key === 'Tab') {
          const items = Array.from(drawer.querySelectorAll(focusableSel)).filter(x=>x && x.offsetParent !== null);
          if (!items.length) return;
          const first = items[0], last = items[items.length - 1];
          if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
          else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
      }

      // Wire up
  btn.addEventListener('click', (e)=>{ if(isMobile()){ e.preventDefault(); toggle(); }});
      overlay.addEventListener('click', close);
      drawer.querySelectorAll('[data-drawer-close]').forEach(el=> el.addEventListener('click', close));
      // Close on any link click
      drawer.querySelectorAll('a[href]').forEach(a=> a.addEventListener('click', ()=>{ if(isMobile()) close(); }, { passive:true }));

      // Reset on resize up to desktop
      let rafId = 0;
      function onResize(){
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(()=>{
          if (!isMobile()) {
            // Ensure desktop state
            drawer.classList.remove('translate-x-full');
            drawer.classList.add('pointer-events-auto');
            overlay.classList.remove('opacity-100','pointer-events-auto');
            drawer.setAttribute('aria-hidden','false');
            btn.setAttribute('aria-expanded','false');
            document.body.classList.remove('overflow-hidden');
          } else {
            // Ensure closed on mobile by default
            drawer.classList.add('translate-x-full','pointer-events-none');
            drawer.setAttribute('aria-hidden','true');
            overlay.classList.remove('opacity-100','pointer-events-auto');
          }
        });
      }
      window.addEventListener('resize', onResize);
      // Initial sync
      onResize();
    }
    function initAccordions(){
      document.querySelectorAll('[data-accordion]').forEach(acc=>{
        const mode = (acc.getAttribute('data-accordion')||'').toLowerCase();
        const alwaysOpen = mode === 'open'; // Flowbite: "open" allows multiple; others collapse
        const buttons = Array.from(acc.querySelectorAll('[data-accordion-target]'));
        // Helper to update one item
        function update(btn, expanded){
          const selector = btn.getAttribute('data-accordion-target');
          const id = selector && selector.replace(/^#/, '');
          const panel = id && document.getElementById(id);
          const icon = btn.querySelector('[data-accordion-icon]');
          btn.setAttribute('aria-expanded', String(!!expanded));
          if(panel) panel.classList.toggle('hidden', !expanded);
          if(icon) icon.classList.toggle('rotate-180', !expanded);
        }
        // Initial state sync (respect server-rendered aria-expanded/hidden)
        buttons.forEach(btn=>{
          const sel = btn.getAttribute('data-accordion-target');
          const id = sel && sel.replace(/^#/, '');
          const panel = id && document.getElementById(id);
          const expanded = btn.getAttribute('aria-expanded') === 'true' || (panel && !panel.classList.contains('hidden'));
          update(btn, expanded);
        });
        // Click wiring
        buttons.forEach(btn=>{
          btn.addEventListener('click', ()=>{
            const currentlyExpanded = btn.getAttribute('aria-expanded') === 'true';
            const next = !currentlyExpanded;
            if(!alwaysOpen && next){
              // Close others in this accordion
              buttons.forEach(other=>{ if(other===btn) return; update(other, false); });
            }
            update(btn, next);
          });
        });
      });
    }
    // Lightweight, dependency-free carousel initializer
    function initLiteCarousels(){
      const carousels = Array.from(document.querySelectorAll('[data-lite-carousel]'));
      if(!carousels.length) return;
      carousels.forEach(root=>{
        const slides = Array.from(root.querySelectorAll('.lite-slide'));
        const dots = Array.from(root.querySelectorAll('.lite-dot'));
        const prev = root.querySelector('.lite-prev');
        const next = root.querySelector('.lite-next');
        if(!slides.length) return;
        let index = 0;
        let timer = 0;
        const autoStartMode = (root.getAttribute('data-auto-start')||'load').toLowerCase(); // load | interact | visible

        function apply(){
          slides.forEach((el,i)=>{
            const offset = (i - index) * 100;
            el.style.transform = `translateX(${offset}%)`;
            // Keep only current and immediate neighbors unhidden; hide others to prevent eager loads
            const near = (i === index) || (i === (index + 1) % slides.length) || (i === (index - 1 + slides.length) % slides.length);
            if (near) { el.removeAttribute('hidden'); el.setAttribute('aria-hidden', String(i!==index)); }
            else { el.setAttribute('hidden',''); el.setAttribute('aria-hidden','true'); }
          });
          dots.forEach((d,i)=>{
            d.setAttribute('aria-current', String(i===index));
          });
        }
        function goTo(i){ index = (i + slides.length) % slides.length; apply(); }
        function goPrev(){ goTo(index - 1); }
        function goNext(){ goTo(index + 1); }

        dots.forEach(d=>{
          const i = parseInt(d.getAttribute('data-go-to')||'0',10) || 0;
          d.addEventListener('click', ()=> goTo(i));
        });
        if(prev) prev.addEventListener('click', goPrev);
        if(next) next.addEventListener('click', goNext);

        // Autoplay (optional): data-auto-interval="ms" or data-auto to use default
        function startAuto(){
          // Respect reduced motion preference
          if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
          if (timer) clearInterval(timer);
          const attr = root.getAttribute('data-auto-interval');
          const ms = attr ? parseInt(attr, 10) : 0;
          const interval = (!isNaN(ms) && ms > 0) ? ms : 0;
          if (interval) timer = setInterval(goNext, interval);
        }
        function stopAuto(){ if (timer) { clearInterval(timer); timer = 0; } }
        function setupAutoStart(){
          if (!root.getAttribute('data-auto-interval')) return; // nothing to do if no interval set
          switch(autoStartMode){
            case 'interact': {
              let fired = false;
              const onUser = ()=>{ if(fired) return; fired = true; startAuto(); cleanup(); };
              const cleanup = ()=>{
                window.removeEventListener('scroll', onUser, { passive:true });
                window.removeEventListener('mousemove', onUser);
                window.removeEventListener('touchstart', onUser, { passive:true });
                window.removeEventListener('keydown', onUser);
              };
              window.addEventListener('scroll', onUser, { passive:true });
              window.addEventListener('mousemove', onUser);
              window.addEventListener('touchstart', onUser, { passive:true });
              window.addEventListener('keydown', onUser);
              break;
            }
            case 'visible': {
              if ('IntersectionObserver' in window){
                try {
                  const obs = new IntersectionObserver((entries)=>{
                    for(const e of entries){ if(e.isIntersecting){ startAuto(); obs.disconnect(); break; } }
                  }, { root:null, rootMargin:'0px', threshold:0.25 });
                  obs.observe(root);
                } catch { startAuto(); }
              } else { startAuto(); }
              break;
            }
            case 'load':
            default:
              startAuto();
          }
        }

        // Pause on hover/focus within, resume on leave when appropriate
        root.addEventListener('mouseenter', stopAuto);
        root.addEventListener('mouseleave', startAuto);
        root.addEventListener('focusin', stopAuto);
        root.addEventListener('focusout', startAuto);

        // Initial positions then maybe autoplay
        apply();
        setupAutoStart();
      });
    }

    // Defer carousel initialization until user scroll/interaction or when near-viewport
    function setupCarouselLoader(){
      const roots = Array.from(document.querySelectorAll('[data-lite-carousel]'));
      if(!roots.length) return; // no carousels on page
      let fired = false;
      function run(){ if(fired) return; fired = true; cleanup(); initLiteCarousels(); }
      function cleanup(){
        window.removeEventListener('scroll', onUser, { passive:true });
        window.removeEventListener('mousemove', onUser);
        window.removeEventListener('touchstart', onUser, { passive:true });
        window.removeEventListener('keydown', onUser);
        document.removeEventListener('pointerdown', onPointerWithin, true);
        if (obs) try { obs.disconnect(); } catch {}
      }
      function onUser(){ run(); }
      function onPointerWithin(e){ if (e && e.target && e.target.closest && e.target.closest('[data-lite-carousel]')) run(); }
      // Gate on user interaction (like analytics/scripts)
      window.addEventListener('scroll', onUser, { passive:true });
      window.addEventListener('mousemove', onUser);
      window.addEventListener('touchstart', onUser, { passive:true });
      window.addEventListener('keydown', onUser);
      document.addEventListener('pointerdown', onPointerWithin, true);
      // Or when any carousel comes near viewport
      let obs = null;
      if ('IntersectionObserver' in window){
        try {
          obs = new IntersectionObserver((entries)=>{
            for (const e of entries){ if (e.isIntersecting) { run(); break; } }
          }, { root:null, rootMargin:'400px', threshold:0.01 });
          roots.forEach(r=>obs.observe(r));
        } catch { /* noop */ }
      }
    }

    ready(()=>{initCollapse();initDropdowns();initMobileDrawer();initAutoCloseMobileMenu();initAccordions();initCarouselHeights();setupCarouselLoader();});
  </script>

  <!-- Header toggle (optional):
       If you have a button with id="theme-toggle" (and two icons with
       ids theme-toggle-dark-icon / theme-toggle-light-icon), this flips
       the same data-force-theme attribute the color-picker uses. -->
  <script defer>
    document.addEventListener('DOMContentLoaded', () => {
      const html      = document.documentElement;
      const btn       = document.getElementById('theme-toggle');
      const darkIcon  = document.getElementById('theme-toggle-dark-icon');
      const lightIcon = document.getElementById('theme-toggle-light-icon');

      function syncIcons() {
        const isDark = html.classList.contains('dark');
        // Show the icon for the state you can switch TO (common UI pattern)
        if (darkIcon)  darkIcon.classList.toggle('hidden', isDark);     // show moon in light mode
        if (lightIcon) lightIcon.classList.toggle('hidden', !isDark);   // show sun in dark mode
      }

      function flipForcedTheme() {
        const forced = html.getAttribute('data-force-theme'); // "light" | "dark" | null
        if (forced === 'dark')      html.setAttribute('data-force-theme', 'light');
        else if (forced === 'light')html.setAttribute('data-force-theme', 'dark');
        else {
          // No override yet: flip away from current OS/effective state
          const isDark = html.classList.contains('dark');
          html.setAttribute('data-force-theme', isDark ? 'light' : 'dark');
        }
        // Head script will react and toggle html.dark; then update icons
        syncIcons();
      }

      // Initial icon state
      syncIcons();

      // Wire the button if present
      if (btn) btn.addEventListener('click', flipForcedTheme);
    });
  </script>

  <!-- Lazy-load Elfsight only when needed (below-the-fold + gated) -->
  <script>
    (function(){
      var loaded = false;
      function loadElfsight(){
        if (loaded) return; loaded = true;
        var s = document.createElement('script');
        s.src = 'https://static.elfsight.com/platform/platform.js';
        s.async = true;
        document.head.appendChild(s);
      }
      function onIntersect(entries, obs){
        for (var i=0;i<entries.length;i++){
          var e = entries[i];
          if (e.isIntersecting){ loadElfsight(); obs.disconnect(); break; }
        }
      }
      function setup(){
        try {
          var el = document.querySelector('[class^="elfsight-app-"]');
          if (!el) return; // no widget on this page
        } catch { return; }

        // Gate on user interaction OR when the widget comes near viewport
        var once = function(fn){ return function(){ fn();
          window.removeEventListener('scroll', onUser, {passive:true});
          window.removeEventListener('mousemove', onUser);
          window.removeEventListener('touchstart', onUser, {passive:true});
        }};
        var onUser = once(loadElfsight);
        window.addEventListener('scroll', onUser, {passive:true});
        window.addEventListener('mousemove', onUser);
        window.addEventListener('touchstart', onUser, {passive:true});

        // IntersectionObserver for the widget container
        if ('IntersectionObserver' in window){
          try {
            var obs = new IntersectionObserver(onIntersect, { root: null, rootMargin: '400px', threshold: 0.01 });
            document.querySelectorAll('[class^="elfsight-app-"]').forEach(function(node){ obs.observe(node); });
          } catch { /* noop */ }
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setup, { once:true });
      } else { setup(); }
    })();
  </script>

  <!-- Lazy video initializer (used by {{`<`}} video {{`>`}} shortcode when lazy=true) -->
  <script>
    (function(){
      function loadVideo(v){
        if (!v || v.__loaded) return; v.__loaded = true;
        var src = v.getAttribute('data-src');
        var sources = v.querySelectorAll('source[data-src]');
        if (src && !v.getAttribute('src')) v.setAttribute('src', src);
        sources.forEach(function(s){ s.setAttribute('src', s.getAttribute('data-src')); s.removeAttribute('data-src'); });
        try { v.load(); } catch(e){}
        if (v.getAttribute('data-autoplay') === '1'){
          var p = v.play && v.play(); if (p && p.catch) p.catch(function(){});
        }
      }
      function onIntersect(entries, obs){
        for (var i=0;i<entries.length;i++){
          var e = entries[i];
          if (e.isIntersecting){ loadVideo(e.target); obs.unobserve(e.target); }
        }
      }
      function initLazyVideos(){
        var vids = document.querySelectorAll('video[data-video-lazy]');
        if (!vids.length) return;
        if ('IntersectionObserver' in window){
          try {
            var obs = new IntersectionObserver(onIntersect, { root:null, rootMargin:'200px', threshold:0.01 });
            vids.forEach(function(v){ obs.observe(v); });
          } catch { vids.forEach(loadVideo); }
        } else { vids.forEach(loadVideo); }
      }
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initLazyVideos, { once:true });
      else initLazyVideos();
    })();
  </script>



  <!-- Calculate header height and set --site-header-offset so CSS can align anchors correctly -->
  <!-- header offset script removed to restore default CSS behavior -->

  {{/* Footer (supports content/footer.md via partial) */}}
  {{ partialCached "footer.html" . .Layout .Kind (.Param "hideFooter") (.Param "ShowCodeCopyButtons") }}
</body>
</html>
