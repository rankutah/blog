{{/* themes/overrides/layouts/_default/flowbite.html */}}
<!DOCTYPE html>
{{/* Compute lightweight bg class hints for <html> so we can mirror color-picker behavior without JS maps */}}
{{- $lightParam := lower (or .Site.Params.lightBackground "gray-200") -}}
{{- $darkParam  := lower (or .Site.Params.darkBackground  "zinc-900") -}}
{{- /* strip any prefixes */ -}}
{{- if strings.HasPrefix $lightParam "dark:bg-" -}}{{- $lightParam = replace $lightParam "dark:bg-" "" -}}{{- end -}}
{{- if strings.HasPrefix $lightParam "bg-" -}}{{- $lightParam = replace $lightParam "bg-" "" -}}{{- end -}}
{{- if strings.HasPrefix $darkParam "dark:bg-" -}}{{- $darkParam = replace $darkParam "dark:bg-" "" -}}{{- end -}}
{{- if strings.HasPrefix $darkParam "bg-" -}}{{- $darkParam = replace $darkParam "bg-" "" -}}{{- end -}}
{{- /* normalize to plain bg-* classes usable on <html> itself */ -}}
{{- $htmlLight := cond (eq $lightParam "white") "bg-white" (printf "bg-%s" $lightParam) -}}
{{- $htmlDark  := cond (eq $darkParam  "black") "bg-black" (printf "bg-%s"  $darkParam)  -}}

{{- /* Theme storage keys are per-site to avoid cross-site bleeding when using the same browser */ -}}
{{- $defaultTheme := (site.Params.defaultTheme | default "auto") -}}
{{- $themeSiteKey := os.Getenv "HUGO_SITE" -}}
{{- if not $themeSiteKey -}}
  {{- $themeHost := "" -}}
  {{- with (urls.Parse site.BaseURL) -}}
    {{- $themeHost = .Host -}}
  {{- end -}}
  {{- $titleSlug := urlize site.Title -}}
  {{- if and $themeHost $titleSlug -}}
    {{- $themeSiteKey = printf "%s|%s" $themeHost $titleSlug -}}
  {{- else if $themeHost -}}
    {{- $themeSiteKey = $themeHost -}}
  {{- else -}}
    {{- $themeSiteKey = $titleSlug -}}
  {{- end -}}
{{- end -}}
{{- $themeStorageKey := cond $themeSiteKey (printf "pref-theme:%s" $themeSiteKey) "pref-theme" -}}
{{- $themeRecoveredKey := cond $themeSiteKey (printf "pref-theme:recovered:%s" $themeSiteKey) "pref-theme:recovered" -}}

<html class="{{ .Site.Params.primaryColor | default "rose" }}" lang="{{ .Site.Language.Lang }}" dir="{{ .Site.Language.LanguageDirection | default "auto" }}" data-force-theme="{{ .Site.Params.forceTheme }}" data-default-theme="{{ $defaultTheme }}" data-theme-storage-key="{{ $themeStorageKey }}" data-theme-recovered-key="{{ $themeRecoveredKey }}" data-bg-light="{{ $htmlLight }}" data-bg-dark="{{ $htmlDark }}">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ if and .Title (ne .Title .Site.Title) (gt (len (trim .Title " \n\r\t")) 0) }}{{ .Site.Title }} | {{ .Title }}{{ else }}{{ .Site.Title }}{{ end }}</title>

  {{ partial "seo-meta.html" . }}

  {{- /* LCP preload: emit as early as possible so the hero image request starts sooner */ -}}
  {{ partial "lcp-preload.html" . }}

  <!-- Theme bootstrap: tiny pre-paint apply to avoid blocking first render/LCP -->
  <script>
    (function(){
      var html = document.documentElement;
      var defaultTheme = html.getAttribute('data-default-theme') || 'auto';
      var storageKey = html.getAttribute('data-theme-storage-key') || 'pref-theme';
      function prefersDark(){ try { return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(e){ return false; } }
      var forced = html.getAttribute('data-force-theme');
      var stored = null;
      try { stored = localStorage.getItem(storageKey); } catch(e) {}
      var isDark = (forced === 'dark') || (forced !== 'light' && (stored === 'dark' || (stored !== 'light' && (defaultTheme === 'dark' || (defaultTheme === 'auto' && prefersDark())))));
      if (isDark) html.classList.add('dark'); else html.classList.remove('dark');
      try { html.setAttribute('data-theme', isDark ? 'dark' : 'light'); } catch(e) {}
      // Apply html background class only (body sync happens in deferred runtime)
      try {
        var lightCls = html.getAttribute('data-bg-light');
        var darkCls  = html.getAttribute('data-bg-dark');
        if (lightCls) html.classList.remove(lightCls);
        if (darkCls)  html.classList.remove(darkCls);
        if (isDark) { if (darkCls)  html.classList.add(darkCls); }
        else        { if (lightCls) html.classList.add(lightCls); }
      } catch(e) {}
    })();
  </script>

  {{- /* Deferred theme runtime: observers, body sync, and brand recolor */ -}}
  {{- $themeRuntime := resources.Get "js/theme-runtime.js" | resources.Minify | resources.Fingerprint -}}
  <script src="{{ $themeRuntime.RelPermalink }}" defer></script>

  <!-- Flowbite JS removed: no sites enable it, and baseline avoids extra JS. -->

  {{- /* Styles: centralized bundle via partial for uniform behavior */ -}}
  {{ partial "styles.html" . }}

  {{/* Config-driven font overrides (site-wide) */}}
  {{ partial "fonts.html" . }}

  {{/* Config-driven brand color overrides (buttons/links) */}}
  {{ partial "brand-colors.html" . }}

  {{/* Colored tag badges CSS */}}
  {{ partial "taxonomy-badges.html" . }}


  <!-- Carousel v2 scoped polish (fallbacks for visibility/positioning) -->
  <style>
    /* Ensure viewport is positioning context */
    [data-carousel-ver="2"] [data-carousel-viewport] { position: relative; }
    /* Dots visible by default; brighter when active via aria-current */
    [data-carousel-ver="2"] [data-carousel-slide-to] {
      width: 0.75rem; height: 0.75rem; border-radius: 9999px;
      background-color: rgba(255, 255, 255, 0.35);
    }
    [data-carousel-ver="2"] [data-carousel-slide-to][aria-current="true"] {
      background-color: rgba(255, 255, 255, 0.9);
    }
    /* Vertical centering fallback for nav arrows */
    [data-carousel-ver="2"] [data-carousel-prev],
    [data-carousel-ver="2"] [data-carousel-next] {
      position: absolute; top: 50%; transform: translateY(-50%);
    }

    /* Lite carousel (custom) styles */
    /* Lite carousel base positioning */
    [data-lite-carousel] [data-carousel-viewport] { position: relative; }
  /* Initial offscreen positioning so only the first slide is in view before JS runs */
  [data-lite-carousel] .lite-slide { transform: translateX(100%); }
  [data-lite-carousel] .lite-slide[data-index="0"] { transform: translateX(0); }
    /* Uniform heights via CSS variables (set on the carousel root) */
    /* Slightly lower default on mobile to keep controls within frame */
    [data-lite-carousel] [data-carousel-viewport] { height: var(--lc-h-mobile, 520px); }
    @media (min-width: 768px) {
      [data-lite-carousel] [data-carousel-viewport] { height: var(--lc-h-md, var(--lc-h-mobile, 520px)); }
    }
    [data-lite-carousel] .lite-dots {
      position: absolute; left: 0; right: 0;
      display: flex; gap: 0.75rem; justify-content: center; align-items: center;
      bottom: clamp(0.5rem, 2.5vh, 1.25rem);
    }
    /* Dots: match arrow colors; unselected = dark pill, selected = solid white */
    [data-lite-carousel] .lite-dot {
      width: 0.8rem; height: 0.8rem; border-radius: 9999px;
      background-color: rgba(0,0,0,0.45); /* same as .lite-nav-bg base */
      border: 1px solid rgba(255,255,255,0.75); /* subtle white border for visibility */
      box-shadow: none; /* solid circle, no extra ring */
    }
    [data-lite-carousel] .lite-dot[aria-current="true"] {
      background-color: rgba(255,255,255,0.98); /* bright white like arrow icon */
    }
    [data-lite-carousel] .lite-dot:focus-visible { outline: 2px solid rgba(255,255,255,0.9); outline-offset: 2px; }

  /* Controls overlay (ensures all controls anchor to viewport bounds) */
  [data-lite-carousel] .lite-controls { position: absolute; inset: 0; z-index: 30; pointer-events: none; display:grid; grid-template-rows: 1fr auto; grid-template-columns: 1fr; }
    [data-lite-carousel] .lite-controls .lite-prev,
    [data-lite-carousel] .lite-controls .lite-next,
    [data-lite-carousel] .lite-controls .lite-dots { pointer-events: auto; }

    /* Nav buttons: darker pill with subtle border and shadow for visibility */
    [data-lite-carousel] .lite-prev > .lite-nav-bg,
    [data-lite-carousel] .lite-next > .lite-nav-bg {
      background-color: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.6);
      box-shadow: 0 2px 6px rgba(0,0,0,0.45);
    }
    [data-lite-carousel] .lite-prev:hover > .lite-nav-bg,
    [data-lite-carousel] .lite-next:hover > .lite-nav-bg {
      background-color: rgba(0,0,0,0.6);
    }
    [data-lite-carousel] .lite-prev,
    [data-lite-carousel] .lite-next { position:absolute; top:50%; transform:translateY(-50%); }

    /* Reduce top gap before first grid heading on non-hero pages */
    /* (Removed legacy .section heading tweak; section wrappers deprecated) */
  </style>

  {{- /* Analytics (match PaperMod behavior: only in production) */ -}}
  {{- if or (hugo.IsProduction) (eq site.Params.env "production") -}}
    {{ partial "google_analytics.html" . }}
  {{- end -}}

  {{- /* Favicons */ -}}
  {{ partial "favicons.html" . }}

  {{- /* JSON-LD schema (Event and per-page LocalBusiness) */ -}}
  {{ partial "schema.html" . }}
</head>

{{- /* Get shared palette once; use for body + navbar */ -}}
{{- $pal := partial "theme/palette.html" . -}}

<body id="top" class="flowbite-landing {{ $pal.bodyBg }} {{ $pal.bodyText }} transition-colors duration-200 twinkle-bg">
  {{ partial "navbar.html" . }}

  {{- /* Determine if page should flush against navbar.
    Previous logic flushed ALL homepages which broke non-hero home designs.
    New rule: only flush if (homepage AND not plainHome flag) OR explicit hero param/image OR landing layout. */ -}}
  {{- $heroVal := (index .Params "hero") -}}
  {{- $heroType := printf "%T" $heroVal -}}
  {{- $heroIsBool := eq $heroType "bool" -}}
  {{- $heroDisabled := and (isset .Params "hero") $heroIsBool (not $heroVal) -}}
  {{- $heroIsMap := hasPrefix $heroType "map" -}}
  {{- $hasHeroDict := and (isset .Params "hero") $heroIsMap -}}
  {{- $hasHeroImage := or (and $hasHeroDict (isset .Params.hero "image")) (isset .Params "heroImage") -}}
  {{- $isHeroPage := or (and .IsHome (not .Params.plainHome) (not $heroDisabled)) (and (isset .Params "hero") (ne $heroVal nil) (not $heroDisabled)) $hasHeroImage (eq .Params.layout "landing") -}}
  <main id="content" class="min-h-screen{{ if $isHeroPage }} no-top-pad{{ end }}" data-bg-sync{{ if $isHeroPage }} style="padding-top:0;margin-top:0"{{ end }}>
        {{- /* Render list pages (sections/taxonomies). Some Hugo setups emit tags pages as Kind "page";
          broaden detection to also catch Type "tags" or URL starting with /tags/. */ -}}
        {{- $isTagsPath := (hasPrefix .RelPermalink "/tags/") -}}
        {{- $isList := or (eq .Kind "section") (eq .Kind "taxonomy") (eq .Kind "taxonomyTerm") (eq .Type "tags") $isTagsPath -}}
        {{- if $isList -}}
      {{- $defs := .Site.Params.section.defaults | default (dict) -}}
      {{- $defMax := (index $defs "max") | default "xl" -}}
      {{- $defPad := (index $defs "pad") | default "lg" -}}
      {{- $maxMap := dict "sm" "max-w-screen-sm" "md" "max-w-3xl" "lg" "max-w-5xl" "xl" "max-w-7xl" "2xl" "max-w-screen-2xl" "full" "max-w-none" -}}
      {{- $padMap := dict "none" "px-0" "sm" "px-4" "md" "px-6" "lg" "px-8" -}}
      {{- $container := printf "%s mx-auto %s" (index $maxMap $defMax | default "max-w-7xl") (index $padMap $defPad | default "px-8") -}}
      <div class="{{ $container }}"{{ if $isHeroPage }} style="margin-top:0"{{ end }}>
        {{- if and (eq .Kind "section") (or (eq .Section "search") (hasPrefix .RelPermalink "/search")) -}}
          {{- /* Dedicated search page under flowbite wrapper */ -}}
          {{- partial "search-page.html" . -}}
        {{- else if eq .Kind "taxonomyTerm" -}}
          {{- /* All Tags listing: chips only */ -}}
          {{- $all := .Site.Taxonomies.tags -}}
          {{- $names := slice -}}
          {{- range $n, $_ := $all }}{{ $names = $names | append $n }}{{ end -}}
          {{- $sorted := sort $names -}}
          {{- if gt (len $sorted) 0 -}}
            <div style="display:flex;flex-wrap:wrap;gap:0.3rem 0.3rem;margin-top:1rem;">
              {{- range $t := $sorted -}}
                {{- $slug := $t | urlize -}}
                <a href="{{ (printf "/tags/%s/" $slug) | relURL }}" class="badge badge-{{ $slug }}" style="font-size:0.875rem;padding:0.25rem 0.75rem;">
                  {{ $t }} ({{ len (index $all $t) }})
                </a>
              {{- end -}}
            </div>
          {{- else -}}
            <p class="text-gray-600 dark:text-gray-400">No tags found.</p>
          {{- end -}}
        {{- else if or (eq .Kind "taxonomy") (or (eq .Type "tags") $isTagsPath) -}}
          {{- /* Single tag page (or pages routed under /tags): Flowbite cards with contextual heading */ -}}
          <h2 class="text-xl md:text-2xl font-semibold mb-4">Showing Tag: {{ .Title }}</h2>
          {{- $tp := .Data.Pages | default .Pages -}}
          {{- /* Fallback: if not a real taxonomy context, derive from Site.Taxonomies.tags */ -}}
          {{- if or (not $tp) (eq (len $tp) 0) -}}
            {{- $tp = (index .Site.Taxonomies.tags .Title) -}}
          {{- end -}}
          {{- $pages := sort $tp "Date" "desc" -}}
          {{- if gt (len $pages) 0 -}}
            {{- partial "list-posts-cards.html" (dict "ctx" . "pages" $pages "showDate" false "showTags" true "excerpt" 160) -}}
          {{- else -}}
            <p class="text-gray-600 dark:text-gray-400">No posts found for this tag.</p>
          {{- end -}}
        {{- else if eq .Kind "section" -}}
          {{- /* Sections render content by default; show child list only when explicitly requested. */ -}}
          {{- $showListParam := lower (printf "%v" .Params.showList) -}}
          {{- $listAfterParam := lower (printf "%v" .Params.listAfterContent) -}}
          {{- $showList := or (eq $showListParam "true") (eq $listAfterParam "true") -}}
          <article class="prose prose-zinc max-w-none dark:prose-invert">{{ .Content }}</article>
          {{- if and $showList (gt (len .Pages) 0) -}}
            {{- $pages := sort .Pages "Date" "desc" -}}
            {{- partial "list-posts-cards.html" (dict "ctx" . "pages" $pages "showDate" false "showTags" true "excerpt" 160) -}}
          {{- end -}}
        {{- else -}}
          {{- $pages := sort .Pages "Date" "desc" -}}
          {{- partial "list-posts-cards.html" (dict "ctx" . "pages" $pages "showDate" false "showTags" true "excerpt" 160) -}}
        {{- end -}}
      </div>
    {{- else -}}
      {{- /* Optional front-matter hero (renders above content if provided). No change unless hero fields exist. */ -}}
      {{- if or $hasHeroImage $hasHeroDict -}}
        {{- $hero := dict -}}
        {{- if $hasHeroDict -}}
          {{- $hero = .Params.hero -}}
        {{- else -}}
          {{- $hero = (dict "image" .Params.heroImage) -}}
        {{- end -}}
        {{- $args := dict
              "page" .
              "image" (or (index $hero "image") (index $hero "img"))
              "alt" (index $hero "alt")
              "bleed" (or (eq (lower (printf "%v" (index $hero "bleed"))) "true") false)
              "overlay" (or (eq (lower (printf "%v" (index $hero "overlay"))) "true") false)
              "overlayShade" (index $hero "overlayShade")
              "imgClasses" (index $hero "imgClasses")
              "imgStyle" (index $hero "imgStyle")
              "vh" (index $hero "vh")
              "brighten" (index $hero "brighten")
              "max" (index $hero "max")
              "pad" (index $hero "pad")
              "align" (index $hero "align")
              "alignY" (index $hero "alignY")
              "minh" (index $hero "minh")
          -}}
        {{- partial "hero.html" $args -}}
      {{- end -}}
      {{- /* Singles: one container + typography; avoid auto-injecting section wrappers */ -}}
      {{- $defs := .Site.Params.section.defaults | default (dict) -}}
      {{- $defMax := (index $defs "max") | default "xl" -}}
      {{- $defPad := (index $defs "pad") | default "lg" -}}
      {{- $maxMap := dict "sm" "max-w-screen-sm" "md" "max-w-3xl" "lg" "max-w-5xl" "xl" "max-w-7xl" "2xl" "max-w-screen-2xl" "full" "max-w-none" -}}
      {{- $padMap := dict "none" "px-0" "sm" "px-4" "md" "px-6" "lg" "px-8" -}}
      {{- $container := printf "%s mx-auto %s" (index $maxMap $defMax | default "max-w-7xl") (index $padMap $defPad | default "px-8") -}}
      <div class="{{ $container }}"{{ if $isHeroPage }} style="margin-top:0"{{ end }}>
        <article class="prose prose-zinc max-w-none dark:prose-invert">{{ .Content }}</article>
      </div>
    {{- end -}}
  </main>



  <!-- Inline tiny UI for navbar collapse/dropdowns (removes JS request chain) -->
  <script type="module">
    function ready(fn){if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',fn,{once:true});}else{fn();}}
    function initCollapse(){
      // Basic collapses; skip if target is our drawer
      document.querySelectorAll('[data-collapse-toggle]').forEach(btn=>{
        const id=btn.getAttribute('data-collapse-toggle');
        const target=id&&document.getElementById(id);
        if(!target) return;
        if (target.hasAttribute('data-drawer')) return; // handled by drawer initializer
        btn.addEventListener('click',()=>{
          const isHidden=target.classList.toggle('hidden');
          btn.setAttribute('aria-expanded',String(!isHidden));
        });
      });
    }
    function initDropdowns(){const buttons=Array.from(document.querySelectorAll('[data-dropdown-toggle]'));if(!buttons.length)return;function closeAll(exceptId){buttons.forEach(b=>{const id=b.getAttribute('data-dropdown-toggle');const el=id&&document.getElementById(id);if(!el||id===exceptId)return;el.classList.add('hidden');b.setAttribute('aria-expanded','false');});}
      buttons.forEach(btn=>{const id=btn.getAttribute('data-dropdown-toggle');const menu=id&&document.getElementById(id);if(!menu)return;btn.addEventListener('click',(e)=>{e.stopPropagation();const nowHidden=menu.classList.toggle('hidden');btn.setAttribute('aria-expanded',String(!nowHidden));if(!nowHidden)closeAll(id);});});
      document.addEventListener('click',(e)=>{const inside=e.target.closest&&(e.target.closest('[data-dropdown-toggle]')||e.target.closest('[id^="menu-"]'));if(!inside)closeAll();});}
    // Apply responsive pixel heights to carousels based on data-* attributes
    function initCarouselHeights(){
      const mqlMd = window.matchMedia('(min-width: 768px)');
      const mqlLg = window.matchMedia('(min-width: 1024px)');
      const viewports = Array.from(document.querySelectorAll('[data-carousel-viewport]'));
      if(!viewports.length) return;

      function apply(){
        viewports.forEach(vp=>{
          const mob = vp.getAttribute('data-mobile-height');
          const md  = vp.getAttribute('data-md-height');
          const lg  = vp.getAttribute('data-lg-height');
          const fixed = vp.getAttribute('data-fixed-height');
          let h = '';
          if (lg && mqlLg.matches) h = lg;
          else if (md && mqlMd.matches) h = md;
          else if (mob) h = mob;
          else if (fixed) h = fixed;
          if (h) {
            const n = parseInt(h, 10);
            if (!isNaN(n)) vp.style.height = n + 'px';
          }
        });
      }
      apply();
      // Re-apply on breakpoint changes and resize
      let rafId = 0;
      function onResize(){
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(apply);
      }
      window.addEventListener('resize', onResize);
      if (mqlMd.addEventListener) {
        mqlMd.addEventListener('change', onResize);
        mqlLg.addEventListener('change', onResize);
      } else if (mqlMd.addListener) { // Safari <14 fallback
        mqlMd.addListener(onResize); mqlLg.addListener(onResize);
      }
    }
    // Auto-close legacy collapsible mobile menu when a menu link is clicked (no-op for drawer)
    function initAutoCloseMobileMenu(){
      const btn = document.querySelector('[data-collapse-toggle="navbar-sticky"]');
      const menu = document.getElementById('navbar-sticky');
      if(!btn||!menu) return;
      if (menu.hasAttribute('data-drawer')) return; // handled by drawer logic
      const isMobile = () => window.matchMedia('(max-width: 1023.98px)').matches; // Treat tablet as mobile-style drawer (below lg)
      menu.querySelectorAll('a[href]').forEach(a=>{
        a.addEventListener('click',()=>{
          if(!isMobile()) return;
          menu.classList.add('hidden');
          btn.setAttribute('aria-expanded','false');
          document.querySelectorAll('[id^="menu-"]').forEach(el=>el.classList.add('hidden'));
          document.querySelectorAll('[data-dropdown-toggle]').forEach(b=>b.setAttribute('aria-expanded','false'));
        }, { passive:true });
      });
    }
    // Mobile drawer for navbar (off-canvas)
    function initMobileDrawer(){
      const btn = document.querySelector('[data-collapse-toggle="navbar-drawer"]');
      const drawer = document.getElementById('navbar-drawer');
      const overlay = document.getElementById('nav-drawer-overlay');
      if(!btn || !drawer || !overlay) return;
      if (!drawer.hasAttribute('data-drawer')) return; // only if configured as drawer
      const isMobile = () => window.matchMedia('(max-width: 1023.98px)').matches; // below lg: include tablet
      let lastFocus = null;
      const focusableSel = 'a[href], button:not([disabled]), [tabindex]:not([tabindex="-1"])';

      function open(){
        drawer.classList.remove('translate-x-full','pointer-events-none');
        overlay.classList.add('opacity-100','pointer-events-auto');
        drawer.setAttribute('aria-hidden','false');
        btn.setAttribute('aria-expanded','true');
        document.body.classList.add('overflow-hidden');
        lastFocus = document.activeElement;
        const first = drawer.querySelector(focusableSel);
        if (first) try{ first.focus(); }catch(e){}
        document.addEventListener('keydown', onKeydown);
        // Fallback: also close if user taps/clicks anywhere outside the drawer or toggle
        document.addEventListener('click', onOutside, true);
      }
      function close(){
        drawer.classList.add('translate-x-full','pointer-events-none');
        overlay.classList.remove('opacity-100','pointer-events-auto');
        drawer.setAttribute('aria-hidden','true');
        btn.setAttribute('aria-expanded','false');
        document.body.classList.remove('overflow-hidden');
        document.removeEventListener('keydown', onKeydown);
        document.removeEventListener('click', onOutside, true);
        if (lastFocus && typeof lastFocus.focus === 'function') try{ lastFocus.focus(); }catch(e){}
      }
      function toggle(){ if(!isMobile()) return; const openState = drawer.getAttribute('aria-hidden') !== 'true'; openState ? close() : open(); }
      function onKeydown(e){
        if (e.key === 'Escape') { e.preventDefault(); close(); return; }
        if (e.key === 'Tab') {
          const items = Array.from(drawer.querySelectorAll(focusableSel)).filter(x=>x && x.offsetParent !== null);
          if (!items.length) return;
          const first = items[0], last = items[items.length - 1];
          if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
          else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
      }
      function onOutside(e){
        // If drawer is open and the click is not within the drawer or on the toggle button, close it
        if (drawer.getAttribute('aria-hidden') === 'true') return;
        const insideDrawer = e.target && e.target.closest && e.target.closest('#navbar-drawer');
        const onToggle = e.target && e.target.closest && e.target.closest('[data-collapse-toggle="navbar-drawer"]');
        if (!insideDrawer && !onToggle) close();
      }

      // Wire up
  btn.addEventListener('click', (e)=>{ if(isMobile()){ e.preventDefault(); toggle(); }});
      overlay.addEventListener('click', close);
      drawer.querySelectorAll('[data-drawer-close]').forEach(el=> el.addEventListener('click', close));
      // Close on any link click
      drawer.querySelectorAll('a[href]').forEach(a=> a.addEventListener('click', ()=>{ if(isMobile()) close(); }, { passive:true }));

      // Reset on resize up to desktop
      let rafId = 0;
      function onResize(){
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(()=>{
          if (!isMobile()) {
            // Desktop: keep drawer closed and non-interactive
            drawer.classList.add('translate-x-full','pointer-events-none');
            drawer.setAttribute('aria-hidden','true');
            btn.setAttribute('aria-expanded','false');
            overlay.classList.remove('opacity-100','pointer-events-auto');
            document.body.classList.remove('overflow-hidden');
          } else {
            // Mobile/Tablet: ensure closed by default
            drawer.classList.add('translate-x-full','pointer-events-none');
            drawer.setAttribute('aria-hidden','true');
            btn.setAttribute('aria-expanded','false');
            overlay.classList.remove('opacity-100','pointer-events-auto');
          }
        });
      }
      window.addEventListener('resize', onResize);
      // Initial sync
      onResize();
    }
    function initAccordions(){
      document.querySelectorAll('[data-accordion]').forEach(acc=>{
        const mode = (acc.getAttribute('data-accordion')||'').toLowerCase();
        const alwaysOpen = mode === 'open'; // Flowbite: "open" allows multiple; others collapse
        const buttons = Array.from(acc.querySelectorAll('[data-accordion-target]'));
        const isMobile = ()=> (window.matchMedia ? window.matchMedia('(max-width: 767px)').matches : false);
        // Helper to update one item
        function update(btn, expanded){
          const selector = btn.getAttribute('data-accordion-target');
          const id = selector && selector.replace(/^#/, '');
          const panel = id && document.getElementById(id);
          const icon = btn.querySelector('[data-accordion-icon]');
          btn.setAttribute('aria-expanded', String(!!expanded));
          if(panel) panel.classList.toggle('hidden', !expanded);
          if(icon) icon.classList.toggle('rotate-180', !expanded);

          // Visual affordance: highlight the active item
          btn.classList.toggle('bg-gray-100', !!expanded);
          btn.classList.toggle('dark:bg-gray-800', !!expanded);
          btn.classList.toggle('font-semibold', !!expanded);
        }
        // Initial state sync (respect server-rendered aria-expanded/hidden)
        buttons.forEach(btn=>{
          const sel = btn.getAttribute('data-accordion-target');
          const id = sel && sel.replace(/^#/, '');
          const panel = id && document.getElementById(id);
          const expanded = btn.getAttribute('aria-expanded') === 'true' || (panel && !panel.classList.contains('hidden'));
          update(btn, expanded);
        });
        // Click wiring
        buttons.forEach(btn=>{
          btn.addEventListener('click', (e)=>{
            // Prevent odd mobile scroll jumps when expanding/collapsing (layout reflow + scroll anchoring)
            const shouldStabilize = isMobile();
            const topBefore = shouldStabilize ? btn.getBoundingClientRect().top : 0;
            const currentlyExpanded = btn.getAttribute('aria-expanded') === 'true';
            const next = !currentlyExpanded;
            if(!alwaysOpen && next){
              // Close others in this accordion
              buttons.forEach(other=>{ if(other===btn) return; update(other, false); });
            }
            update(btn, next);

            if(shouldStabilize){
              requestAnimationFrame(()=>{
                const topAfter = btn.getBoundingClientRect().top;
                const delta = topAfter - topBefore;
                if (Math.abs(delta) > 1) window.scrollBy(0, delta);
              });
            }
          });
        });
      });
    }
    // Lightweight, dependency-free carousel initializer
    function initLiteCarousels(){
      const carousels = Array.from(document.querySelectorAll('[data-lite-carousel]'));
      if(!carousels.length) return;
      carousels.forEach(root=>{
        const slides = Array.from(root.querySelectorAll('.lite-slide'));
        const dots = Array.from(root.querySelectorAll('.lite-dot'));
        const prev = root.querySelector('.lite-prev');
        const next = root.querySelector('.lite-next');
        if(!slides.length) return;
        let index = 0;
        let timer = 0;
        const autoStartMode = (root.getAttribute('data-auto-start')||'load').toLowerCase(); // load | interact | visible

        function apply(){
          slides.forEach((el,i)=>{
            const offset = (i - index) * 100;
            el.style.transform = `translateX(${offset}%)`;
            // Keep only current and immediate neighbors unhidden; hide others to prevent eager loads
            const near = (i === index) || (i === (index + 1) % slides.length) || (i === (index - 1 + slides.length) % slides.length);
            if (near) { el.removeAttribute('hidden'); el.setAttribute('aria-hidden', String(i!==index)); }
            else { el.setAttribute('hidden',''); el.setAttribute('aria-hidden','true'); }
          });
          dots.forEach((d,i)=>{
            d.setAttribute('aria-current', String(i===index));
          });
        }
        function goTo(i){ index = (i + slides.length) % slides.length; apply(); }
        function goPrev(){ goTo(index - 1); }
        function goNext(){ goTo(index + 1); }

        dots.forEach(d=>{
          const i = parseInt(d.getAttribute('data-go-to')||'0',10) || 0;
          d.addEventListener('click', ()=> goTo(i));
        });
        if(prev) prev.addEventListener('click', goPrev);
        if(next) next.addEventListener('click', goNext);

        // Autoplay (optional): data-auto-interval="ms" or data-auto to use default
        function startAuto(){
          // Respect reduced motion preference
          if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
          if (timer) clearInterval(timer);
          const attr = root.getAttribute('data-auto-interval');
          const ms = attr ? parseInt(attr, 10) : 0;
          const interval = (!isNaN(ms) && ms > 0) ? ms : 0;
          if (interval) timer = setInterval(goNext, interval);
        }
        function stopAuto(){ if (timer) { clearInterval(timer); timer = 0; } }
        function setupAutoStart(){
          if (!root.getAttribute('data-auto-interval')) return; // nothing to do if no interval set
          switch(autoStartMode){
            case 'interact': {
              let fired = false;
              const onUser = ()=>{ if(fired) return; fired = true; startAuto(); cleanup(); };
              const cleanup = ()=>{
                window.removeEventListener('scroll', onUser, { passive:true });
                window.removeEventListener('mousemove', onUser);
                window.removeEventListener('touchstart', onUser, { passive:true });
                window.removeEventListener('keydown', onUser);
              };
              window.addEventListener('scroll', onUser, { passive:true });
              window.addEventListener('mousemove', onUser);
              window.addEventListener('touchstart', onUser, { passive:true });
              window.addEventListener('keydown', onUser);
              break;
            }
            case 'visible': {
              if ('IntersectionObserver' in window){
                try {
                  const obs = new IntersectionObserver((entries)=>{
                    for(const e of entries){ if(e.isIntersecting){ startAuto(); obs.disconnect(); break; } }
                  }, { root:null, rootMargin:'0px', threshold:0.25 });
                  obs.observe(root);
                } catch { startAuto(); }
              } else { startAuto(); }
              break;
            }
            case 'load':
            default:
              startAuto();
          }
        }

        // Pause on hover/focus within, resume on leave when appropriate
        root.addEventListener('mouseenter', stopAuto);
        root.addEventListener('mouseleave', startAuto);
        root.addEventListener('focusin', stopAuto);
        root.addEventListener('focusout', startAuto);

        // Initial positions then maybe autoplay
        apply();
        setupAutoStart();
      });
    }

    // Defer carousel initialization until user scroll/interaction or when near-viewport
    function setupCarouselLoader(){
      const roots = Array.from(document.querySelectorAll('[data-lite-carousel]'));
      if(!roots.length) return; // no carousels on page
      let fired = false;
      function run(){ if(fired) return; fired = true; cleanup(); initLiteCarousels(); }
      function cleanup(){
        window.removeEventListener('scroll', onUser, { passive:true });
        window.removeEventListener('mousemove', onUser);
        window.removeEventListener('touchstart', onUser, { passive:true });
        window.removeEventListener('keydown', onUser);
        document.removeEventListener('pointerdown', onPointerWithin, true);
        if (obs) try { obs.disconnect(); } catch {}
      }
      function onUser(){ run(); }
      function onPointerWithin(e){ if (e && e.target && e.target.closest && e.target.closest('[data-lite-carousel]')) run(); }
      // Gate on user interaction (like analytics/scripts)
      window.addEventListener('scroll', onUser, { passive:true });
      window.addEventListener('mousemove', onUser);
      window.addEventListener('touchstart', onUser, { passive:true });
      window.addEventListener('keydown', onUser);
      document.addEventListener('pointerdown', onPointerWithin, true);
      // Or when any carousel comes near viewport
      let obs = null;
      if ('IntersectionObserver' in window){
        try {
          obs = new IntersectionObserver((entries)=>{
            for (const e of entries){ if (e.isIntersecting) { run(); break; } }
          }, { root:null, rootMargin:'400px', threshold:0.01 });
          roots.forEach(r=>obs.observe(r));
        } catch { /* noop */ }
      }
    }

    // Minimal Lightbox for gallery anchors (data-lightbox="gallery")
    function initLightbox(){
      const links = Array.from(document.querySelectorAll('a[data-lightbox="gallery"]'));
      if(!links.length) return;
      let overlay = document.getElementById('lb-overlay');
      if(!overlay){
        overlay = document.createElement('div');
        overlay.id = 'lb-overlay';
        overlay.setAttribute('aria-hidden','true');
        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:1000;';
        const img = document.createElement('img');
        img.id = 'lb-image'; img.alt = '';
        img.style.cssText = 'max-width:92vw;max-height:88vh;border-radius:0.75rem;box-shadow:0 10px 24px rgba(0,0,0,0.55)';
        const close = document.createElement('button');
        close.id='lb-close'; close.innerHTML='\u2715';
        close.style.cssText='position:absolute;top:1rem;right:1rem;background:transparent;color:#fff;font-size:1.5rem;border:none;cursor:pointer;';
        const prev = document.createElement('button');
        prev.id='lb-prev';
        prev.style.cssText='position:absolute;left:5vw;top:50%;transform:translateY(-50%);background:rgba(0,0,0,0.6);color:#fff;border:1px solid rgba(255,255,255,0.35);padding:0.75rem;border-radius:9999px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 12px rgba(0,0,0,0.4)';
        prev.setAttribute('aria-label','Previous');
        prev.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>';
        const next = document.createElement('button');
        next.id='lb-next';
        next.style.cssText='position:absolute;right:5vw;top:50%;transform:translateY(-50%);background:rgba(0,0,0,0.6);color:#fff;border:1px solid rgba(255,255,255,0.35);padding:0.75rem;border-radius:9999px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 12px rgba(0,0,0,0.4)';
        next.setAttribute('aria-label','Next');
        next.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>';
        overlay.appendChild(img); overlay.appendChild(close);
        overlay.appendChild(prev); overlay.appendChild(next);
        document.body.appendChild(overlay);
        let index = -1;
        function hide(){ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); document.body.classList.remove('overflow-hidden'); index = -1; }
        function showAt(i){
          if (i < 0) i = links.length - 1;
          if (i >= links.length) i = 0;
          index = i;
          const href = links[index].getAttribute('href');
          const imgEl = document.getElementById('lb-image');
          if (imgEl && href) imgEl.src = href;
          overlay.style.display='flex'; overlay.setAttribute('aria-hidden','false'); document.body.classList.add('overflow-hidden');
        }
        function show(src){
          const i = links.findIndex(a=>a.getAttribute('href')===src);
          showAt(i >= 0 ? i : 0);
        }
        function goPrev(){ if(index===-1) return; showAt(index-1); }
        function goNext(){ if(index===-1) return; showAt(index+1); }
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hide(); });
        close.addEventListener('click', hide);
        prev.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); goPrev(); });
        next.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); goNext(); });
        // Touch swipe navigation for lightbox (mobile-friendly)
        let sx = 0, sy = 0, swiping = false;
        overlay.addEventListener('touchstart', (e)=>{
          const t = e.changedTouches && e.changedTouches[0];
          if (!t) return; sx = t.clientX; sy = t.clientY; swiping = true;
        }, { passive:true });
        overlay.addEventListener('touchend', (e)=>{
          if (!swiping) return; swiping = false;
          const t = e.changedTouches && e.changedTouches[0];
          if (!t) return; const dx = t.clientX - sx; const dy = t.clientY - sy;
          if (Math.abs(dy) > Math.abs(dx)) return; // ignore vertical drags
          const THRESHOLD = 40;
          if (dx <= -THRESHOLD) goNext();
          else if (dx >= THRESHOLD) goPrev();
        }, { passive:true });
        document.addEventListener('keydown', (e)=>{
          if(overlay.style.display==='flex'){
            if(e.key==='Escape') hide();
            else if(e.key==='ArrowLeft') goPrev();
            else if(e.key==='ArrowRight') goNext();
          }
        });
        overlay.__show = show; overlay.__hide = hide; overlay.__showAt = showAt;
      }
      const show = overlay.__show;
      links.forEach(a=>{
        a.addEventListener('click', (e)=>{ e.preventDefault(); const href=a.getAttribute('href'); if(href) show(href); });
      });
    }
    function enableCarouselSwipe(){
      const roots = Array.from(document.querySelectorAll('[data-carousel]'));
      const THRESHOLD = 40; // px
      roots.forEach(root=>{
        let startX = 0, startY = 0, swiping = false, blocked = false;
        const nextBtn = root.querySelector('[data-carousel-next]');
        const prevBtn = root.querySelector('[data-carousel-prev]');
        function onTouchStart(e){
          const t = e.changedTouches && e.changedTouches[0];
          if (!t) return;
          startX = t.clientX; startY = t.clientY; swiping = true; blocked = false;
        }
        function onTouchMove(e){
          if (!swiping) return;
          const t = e.changedTouches && e.changedTouches[0];
          if (!t) return;
          const dx = t.clientX - startX; const dy = t.clientY - startY;
          // If primarily horizontal, prevent scrolling to allow swipe
          if (Math.abs(dx) > Math.abs(dy)) { e.preventDefault(); blocked = true; }
        }
        function onTouchEnd(e){
          if (!swiping) return; swiping = false;
          const t = e.changedTouches && e.changedTouches[0];
          if (!t) return;
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
          // Ignore mostly vertical gestures
          if (Math.abs(dy) > Math.abs(dx)) return;
          if (dx <= -THRESHOLD) {
            if (nextBtn) nextBtn.click();
            else if (window.Carousel && typeof window.Carousel.default !== 'undefined') {
              try { const api = window.Carousel.default.getInstance ? window.Carousel.default.getInstance(root) : null; api && api.next && api.next(); } catch {}
            }
          } else if (dx >= THRESHOLD) {
            if (prevBtn) prevBtn.click();
            else if (window.Carousel && typeof window.Carousel.default !== 'undefined') {
              try { const api = window.Carousel.default.getInstance ? window.Carousel.default.getInstance(root) : null; api && api.prev && api.prev(); } catch {}
            }
          }
        }
        // Use non-passive move to allow preventDefault when swiping horizontally
        root.addEventListener('touchstart', onTouchStart, { passive:true });
        root.addEventListener('touchmove', onTouchMove, { passive:false });
        root.addEventListener('touchend', onTouchEnd, { passive:true });
      });
    }
    ready(()=>{initCollapse();initDropdowns();initMobileDrawer();initAutoCloseMobileMenu();initAccordions();initCarouselHeights();setupCarouselLoader();enableCarouselSwipe();initLightbox();});
  </script>

  <!-- Header toggle (optional):
       If you have a button with id="theme-toggle" (and two icons with
       ids theme-toggle-dark-icon / theme-toggle-light-icon), this flips
       the same data-force-theme attribute the color-picker uses. -->
  <script defer>
    document.addEventListener('DOMContentLoaded', () => {
      const html      = document.documentElement;
      const btn       = document.getElementById('theme-toggle');
      const darkIcon  = document.getElementById('theme-toggle-dark-icon');
      const lightIcon = document.getElementById('theme-toggle-light-icon');

      function syncIcons() {
        const isDark = html.classList.contains('dark');
        // Show the icon for the state you can switch TO (common UI pattern)
        if (darkIcon)  darkIcon.classList.toggle('hidden', isDark);     // show moon in light mode
        if (lightIcon) lightIcon.classList.toggle('hidden', !isDark);   // show sun in dark mode
      }

      function flipForcedTheme() {
        const forced = html.getAttribute('data-force-theme'); // "light" | "dark" | null
        if (forced === 'dark')      html.setAttribute('data-force-theme', 'light');
        else if (forced === 'light')html.setAttribute('data-force-theme', 'dark');
        else {
          // No override yet: flip away from current OS/effective state
          const isDark = html.classList.contains('dark');
          html.setAttribute('data-force-theme', isDark ? 'light' : 'dark');
        }
        // Head script will react and toggle html.dark; then update icons
        syncIcons();
      }

      // Initial icon state
      syncIcons();

      // Wire the button if present
      if (btn) btn.addEventListener('click', flipForcedTheme);
    });
  </script>

  <!-- Lazy-load Elfsight only when needed (below-the-fold + gated) -->
  <script>
    (function(){
      var loaded = false;
      function loadElfsight(){
        if (loaded) return; loaded = true;
        var s = document.createElement('script');
        s.src = 'https://static.elfsight.com/platform/platform.js';
        s.async = true;
        document.head.appendChild(s);
      }
      function onIntersect(entries, obs){
        for (var i=0;i<entries.length;i++){
          var e = entries[i];
          if (e.isIntersecting){ loadElfsight(); obs.disconnect(); break; }
        }
      }
      function setup(){
        try {
          var el = document.querySelector('[class^="elfsight-app-"]');
          if (!el) return; // no widget on this page
        } catch { return; }

        // Gate on user interaction OR when the widget comes near viewport
        var once = function(fn){ return function(){ fn();
          window.removeEventListener('scroll', onUser, {passive:true});
          window.removeEventListener('mousemove', onUser);
          window.removeEventListener('touchstart', onUser, {passive:true});
        }};
        var onUser = once(loadElfsight);
        window.addEventListener('scroll', onUser, {passive:true});
        window.addEventListener('mousemove', onUser);
        window.addEventListener('touchstart', onUser, {passive:true});

        // IntersectionObserver for the widget container
        if ('IntersectionObserver' in window){
          try {
            var obs = new IntersectionObserver(onIntersect, { root: null, rootMargin: '400px', threshold: 0.01 });
            document.querySelectorAll('[class^="elfsight-app-"]').forEach(function(node){ obs.observe(node); });
          } catch { /* noop */ }
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setup, { once:true });
      } else { setup(); }
    })();
  </script>

  <!-- Lazy video initializer (used by {{`<`}} video {{`>`}} shortcode when lazy=true) -->
  <script>
    (function(){
      function loadVideo(v){
        if (!v || v.__loaded) return; v.__loaded = true;
        var src = v.getAttribute('data-src');
        var sources = v.querySelectorAll('source[data-src]');
        if (src && !v.getAttribute('src')) v.setAttribute('src', src);
        sources.forEach(function(s){ s.setAttribute('src', s.getAttribute('data-src')); s.removeAttribute('data-src'); });
        try { v.load(); } catch(e){}
        if (v.getAttribute('data-autoplay') === '1'){
          var p = v.play && v.play(); if (p && p.catch) p.catch(function(){});
        }
      }
      function onIntersect(entries, obs){
        for (var i=0;i<entries.length;i++){
          var e = entries[i];
          if (e.isIntersecting){ loadVideo(e.target); obs.unobserve(e.target); }
        }
      }
      function initLazyVideos(){
        var vids = document.querySelectorAll('video[data-video-lazy]');
        if (!vids.length) return;
        if ('IntersectionObserver' in window){
          try {
            var obs = new IntersectionObserver(onIntersect, { root:null, rootMargin:'200px', threshold:0.01 });
            vids.forEach(function(v){ obs.observe(v); });
          } catch { vids.forEach(loadVideo); }
        } else { vids.forEach(loadVideo); }
      }
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initLazyVideos, { once:true });
      else initLazyVideos();
    })();
  </script>



  <!-- Calculate header height and set --site-header-offset so CSS can align anchors correctly -->
  <!-- header offset script removed to restore default CSS behavior -->

  {{/* Footer (supports content/footer.md via partial) */}}
  {{ partialCached "footer.html" . .Layout .Kind (.Param "hideFooter") (.Param "ShowCodeCopyButtons") }}
  <!-- cp-debug: messageModal.enable = {{ printf "%v" (and (isset .Site.Params "messageModal") (isset .Site.Params.messageModal "enable") (.Site.Params.messageModal.enable)) }} -->
  {{/* FAB + Modal gating:
       - If messageModal.enable = true → include FAB (modal mode) + modal markup
       - Else if messageFab.enable = true → include FAB (link mode)
       No BaseURL fallback to avoid surprises. */}}
  {{ $mm := .Site.Params.messageModal }}
  {{ $fab := .Site.Params.messageFab }}
  {{ if and $mm ($mm.enable) }}
    {{ partial "text-fab.html" . }}
    {{ partial "message-modal.html" . }}
  {{ else if and $fab ($fab.enable) }}
    {{ partial "text-fab.html" . }}
  {{ end }}
</body>
</html>
